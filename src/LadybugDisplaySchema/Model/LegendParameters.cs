/* 
 * Ladybug Visualization Schema
 *
 * Documentation for Ladybug visualization schema
 *
 * Contact: info@ladybug.tools
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;


namespace LadybugDisplaySchema
{
    /// <summary>
    /// Legend parameters used to customize legends.
    /// </summary>
    [Serializable]
    [DataContract(Name = "LegendParameters")]
    public partial class LegendParameters : OpenAPIGenBaseModel, IEquatable<LegendParameters>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LegendParameters" /> class.
        /// </summary>
        /// <param name="min">A number to set the lower boundary of the legend. If Default, the minimum of the values associated with the legend will be used..</param>
        /// <param name="max">A number to set the upper boundary of the legend. If Default, the maximum of the values associated with the legend will be used..</param>
        /// <param name="segmentCount">An integer representing the number of steps between the high and low boundary of the legend. The default is set to 11 or it will be equal to the number of items in the ordinal_dictionary. Any custom values input in here should always be greater than or equal to 2..</param>
        /// <param name="colors">An list of color objects. Default is the Ladybug original colorset..</param>
        /// <param name="title">Text string for Legend title. Typically, the units of the data are used here but the type of data might also be used. (default to &quot;&quot;).</param>
        /// <param name="continuousLegend">Boolean noting whether legend is drawn as a gradient or discrete segments. (default to false).</param>
        /// <param name="ordinalDictionary">Optional dictionary that maps values to text categories. If None, numerical values will be used for the legend segments. If not, text categories will be used and the legend will be ordinal. Note that, if the number of items in the dictionary are less than the segment_count, some segments will not receive any label. Examples for possible dictionaries include: {-1: \&quot;Cold\&quot;, 0: \&quot;Neutral\&quot;, 1: \&quot;Hot\&quot;}, {0: \&quot;False\&quot;, 1: \&quot;True\&quot;}.</param>
        /// <param name="decimalCount">An an integer for the number of decimal places in the legend text. Note that this input has no bearing on the resulting legend text when an ordinal_dictionary is present. (default to 2).</param>
        /// <param name="includeLargerSmaller">Boolean noting whether &gt; and &lt; should be included in legend segment text. (default to false).</param>
        /// <param name="vertical">Boolean noting whether legend is vertical (True) or horizontal (False). (default to true).</param>
        /// <param name="font">Text string to set the font for the legend text. Examples include \&quot;Arial\&quot;, \&quot;Times New Roman\&quot;, \&quot;Courier\&quot;. Note that this parameter may not have an effect on certain interfaces that have limited access to fonts. (default to &quot;Arial&quot;).</param>
        /// <param name="properties3d">A Legend3DParameters object to specify the dimensional properties of the legend when it is rendered in the 3D environment of the geometry scene..</param>
        /// <param name="properties2d">A Legend2DParameters object to specify the dimensional properties of the legend when it is rendered in the 2D plane of a screen..</param>
        /// <param name="userData">Optional dictionary of user data associated with the object.All keys and values of this dictionary should be of a standard data type to ensure correct serialization of the object (eg. str, float, int, list)..</param>
        public LegendParameters
        (
            // Required parameters
           AnyOf<Default, double> min= default, AnyOf<Default, double> max= default, AnyOf<Default, int> segmentCount= default, List<Color> colors= default, string title = "", bool continuousLegend = false, Object ordinalDictionary= default, int decimalCount = 2, bool includeLargerSmaller = false, bool vertical = true, string font = "Arial", Legend3DParameters properties3d= default, Legend2DParameters properties2d= default, Object userData= default// Optional parameters
        ) : base()// BaseClass
        {
            this.Min = min;
            this.Max = max;
            this.SegmentCount = segmentCount;
            this.Colors = colors;
            // use default value if no "title" provided
            this.Title = title ?? "";
            this.ContinuousLegend = continuousLegend;
            this.OrdinalDictionary = ordinalDictionary;
            this.DecimalCount = decimalCount;
            this.IncludeLargerSmaller = includeLargerSmaller;
            this.Vertical = vertical;
            // use default value if no "font" provided
            this.Font = font ?? "Arial";
            this.Properties3d = properties3d;
            this.Properties2d = properties2d;
            this.UserData = userData;

            // Set non-required readonly properties with defaultValue
            this.Type = "LegendParameters";

            // check if object is valid, only check for inherited class
            if (this.GetType() == typeof(LegendParameters))
                this.IsValid(throwException: true);
        }

        //============================================== is ReadOnly 
        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [DataMember(Name = "type")]
        public override string Type { get; protected set; }  = "LegendParameters";

        /// <summary>
        /// A number to set the lower boundary of the legend. If Default, the minimum of the values associated with the legend will be used.
        /// </summary>
        /// <value>A number to set the lower boundary of the legend. If Default, the minimum of the values associated with the legend will be used.</value>
        [DataMember(Name = "min")]
        public AnyOf<Default, double> Min { get; set; } 
        /// <summary>
        /// A number to set the upper boundary of the legend. If Default, the maximum of the values associated with the legend will be used.
        /// </summary>
        /// <value>A number to set the upper boundary of the legend. If Default, the maximum of the values associated with the legend will be used.</value>
        [DataMember(Name = "max")]
        public AnyOf<Default, double> Max { get; set; } 
        /// <summary>
        /// An integer representing the number of steps between the high and low boundary of the legend. The default is set to 11 or it will be equal to the number of items in the ordinal_dictionary. Any custom values input in here should always be greater than or equal to 2.
        /// </summary>
        /// <value>An integer representing the number of steps between the high and low boundary of the legend. The default is set to 11 or it will be equal to the number of items in the ordinal_dictionary. Any custom values input in here should always be greater than or equal to 2.</value>
        [DataMember(Name = "segment_count")]
        public AnyOf<Default, int> SegmentCount { get; set; } 
        /// <summary>
        /// An list of color objects. Default is the Ladybug original colorset.
        /// </summary>
        /// <value>An list of color objects. Default is the Ladybug original colorset.</value>
        [DataMember(Name = "colors")]
        public List<Color> Colors { get; set; } 
        /// <summary>
        /// Text string for Legend title. Typically, the units of the data are used here but the type of data might also be used.
        /// </summary>
        /// <value>Text string for Legend title. Typically, the units of the data are used here but the type of data might also be used.</value>
        [DataMember(Name = "title")]
        public string Title { get; set; }  = "";
        /// <summary>
        /// Boolean noting whether legend is drawn as a gradient or discrete segments.
        /// </summary>
        /// <value>Boolean noting whether legend is drawn as a gradient or discrete segments.</value>
        [DataMember(Name = "continuous_legend")]
        public bool ContinuousLegend { get; set; }  = false;
        /// <summary>
        /// Optional dictionary that maps values to text categories. If None, numerical values will be used for the legend segments. If not, text categories will be used and the legend will be ordinal. Note that, if the number of items in the dictionary are less than the segment_count, some segments will not receive any label. Examples for possible dictionaries include: {-1: \&quot;Cold\&quot;, 0: \&quot;Neutral\&quot;, 1: \&quot;Hot\&quot;}, {0: \&quot;False\&quot;, 1: \&quot;True\&quot;}
        /// </summary>
        /// <value>Optional dictionary that maps values to text categories. If None, numerical values will be used for the legend segments. If not, text categories will be used and the legend will be ordinal. Note that, if the number of items in the dictionary are less than the segment_count, some segments will not receive any label. Examples for possible dictionaries include: {-1: \&quot;Cold\&quot;, 0: \&quot;Neutral\&quot;, 1: \&quot;Hot\&quot;}, {0: \&quot;False\&quot;, 1: \&quot;True\&quot;}</value>
        [DataMember(Name = "ordinal_dictionary")]
        public Object OrdinalDictionary { get; set; } 
        /// <summary>
        /// An an integer for the number of decimal places in the legend text. Note that this input has no bearing on the resulting legend text when an ordinal_dictionary is present.
        /// </summary>
        /// <value>An an integer for the number of decimal places in the legend text. Note that this input has no bearing on the resulting legend text when an ordinal_dictionary is present.</value>
        [DataMember(Name = "decimal_count")]
        public int DecimalCount { get; set; }  = 2;
        /// <summary>
        /// Boolean noting whether &gt; and &lt; should be included in legend segment text.
        /// </summary>
        /// <value>Boolean noting whether &gt; and &lt; should be included in legend segment text.</value>
        [DataMember(Name = "include_larger_smaller")]
        public bool IncludeLargerSmaller { get; set; }  = false;
        /// <summary>
        /// Boolean noting whether legend is vertical (True) or horizontal (False).
        /// </summary>
        /// <value>Boolean noting whether legend is vertical (True) or horizontal (False).</value>
        [DataMember(Name = "vertical")]
        public bool Vertical { get; set; }  = true;
        /// <summary>
        /// Text string to set the font for the legend text. Examples include \&quot;Arial\&quot;, \&quot;Times New Roman\&quot;, \&quot;Courier\&quot;. Note that this parameter may not have an effect on certain interfaces that have limited access to fonts.
        /// </summary>
        /// <value>Text string to set the font for the legend text. Examples include \&quot;Arial\&quot;, \&quot;Times New Roman\&quot;, \&quot;Courier\&quot;. Note that this parameter may not have an effect on certain interfaces that have limited access to fonts.</value>
        [DataMember(Name = "font")]
        public string Font { get; set; }  = "Arial";
        /// <summary>
        /// A Legend3DParameters object to specify the dimensional properties of the legend when it is rendered in the 3D environment of the geometry scene.
        /// </summary>
        /// <value>A Legend3DParameters object to specify the dimensional properties of the legend when it is rendered in the 3D environment of the geometry scene.</value>
        [DataMember(Name = "properties_3d")]
        public Legend3DParameters Properties3d { get; set; } 
        /// <summary>
        /// A Legend2DParameters object to specify the dimensional properties of the legend when it is rendered in the 2D plane of a screen.
        /// </summary>
        /// <value>A Legend2DParameters object to specify the dimensional properties of the legend when it is rendered in the 2D plane of a screen.</value>
        [DataMember(Name = "properties_2d")]
        public Legend2DParameters Properties2d { get; set; } 
        /// <summary>
        /// Optional dictionary of user data associated with the object.All keys and values of this dictionary should be of a standard data type to ensure correct serialization of the object (eg. str, float, int, list).
        /// </summary>
        /// <value>Optional dictionary of user data associated with the object.All keys and values of this dictionary should be of a standard data type to ensure correct serialization of the object (eg. str, float, int, list).</value>
        [DataMember(Name = "user_data")]
        public Object UserData { get; set; } 

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            return "LegendParameters";
        }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString(bool detailed)
        {
            if (!detailed)
                return this.ToString();
            
            var sb = new StringBuilder();
            sb.Append("LegendParameters:\n");
            sb.Append("  Type: ").Append(this.Type).Append("\n");
            sb.Append("  Min: ").Append(this.Min).Append("\n");
            sb.Append("  Max: ").Append(this.Max).Append("\n");
            sb.Append("  SegmentCount: ").Append(this.SegmentCount).Append("\n");
            sb.Append("  Colors: ").Append(this.Colors).Append("\n");
            sb.Append("  Title: ").Append(this.Title).Append("\n");
            sb.Append("  ContinuousLegend: ").Append(this.ContinuousLegend).Append("\n");
            sb.Append("  OrdinalDictionary: ").Append(this.OrdinalDictionary).Append("\n");
            sb.Append("  DecimalCount: ").Append(this.DecimalCount).Append("\n");
            sb.Append("  IncludeLargerSmaller: ").Append(this.IncludeLargerSmaller).Append("\n");
            sb.Append("  Vertical: ").Append(this.Vertical).Append("\n");
            sb.Append("  Font: ").Append(this.Font).Append("\n");
            sb.Append("  Properties3d: ").Append(this.Properties3d).Append("\n");
            sb.Append("  Properties2d: ").Append(this.Properties2d).Append("\n");
            sb.Append("  UserData: ").Append(this.UserData).Append("\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the object from JSON string
        /// </summary>
        /// <returns>LegendParameters object</returns>
        public static LegendParameters FromJson(string json)
        {
            var obj = JsonConvert.DeserializeObject<LegendParameters>(json, JsonSetting.AnyOfConvertSetting);
            if (obj == null)
                return null;
            return obj.Type.ToLower() == obj.GetType().Name.ToLower() && obj.IsValid(throwException: true) ? obj : null;
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>LegendParameters object</returns>
        public virtual LegendParameters DuplicateLegendParameters()
        {
            return FromJson(this.ToJson());
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>OpenAPIGenBaseModel</returns>
        public override OpenAPIGenBaseModel Duplicate()
        {
            return DuplicateLegendParameters();
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>OpenAPIGenBaseModel</returns>
        public override OpenAPIGenBaseModel DuplicateOpenAPIGenBaseModel()
        {
            return DuplicateLegendParameters();
        }
     
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            input = input is AnyOf anyOf ? anyOf.Obj : input;
            return this.Equals(input as LegendParameters);
        }

        /// <summary>
        /// Returns true if LegendParameters instances are equal
        /// </summary>
        /// <param name="input">Instance of LegendParameters to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(LegendParameters input)
        {
            if (input == null)
                return false;
            return base.Equals(input) && 
                    Extension.Equals(this.Type, input.Type) && 
                    Extension.Equals(this.Min, input.Min) && 
                    Extension.Equals(this.Max, input.Max) && 
                    Extension.Equals(this.SegmentCount, input.SegmentCount) && 
                (
                    this.Colors == input.Colors ||
                    Extension.AllEquals(this.Colors, input.Colors)
                ) && 
                    Extension.Equals(this.Title, input.Title) && 
                    Extension.Equals(this.ContinuousLegend, input.ContinuousLegend) && 
                    Extension.Equals(this.OrdinalDictionary, input.OrdinalDictionary) && 
                    Extension.Equals(this.DecimalCount, input.DecimalCount) && 
                    Extension.Equals(this.IncludeLargerSmaller, input.IncludeLargerSmaller) && 
                    Extension.Equals(this.Vertical, input.Vertical) && 
                    Extension.Equals(this.Font, input.Font) && 
                    Extension.Equals(this.Properties3d, input.Properties3d) && 
                    Extension.Equals(this.Properties2d, input.Properties2d) && 
                    Extension.Equals(this.UserData, input.UserData);
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.Min != null)
                    hashCode = hashCode * 59 + this.Min.GetHashCode();
                if (this.Max != null)
                    hashCode = hashCode * 59 + this.Max.GetHashCode();
                if (this.SegmentCount != null)
                    hashCode = hashCode * 59 + this.SegmentCount.GetHashCode();
                if (this.Colors != null)
                    hashCode = hashCode * 59 + this.Colors.GetHashCode();
                if (this.Title != null)
                    hashCode = hashCode * 59 + this.Title.GetHashCode();
                if (this.ContinuousLegend != null)
                    hashCode = hashCode * 59 + this.ContinuousLegend.GetHashCode();
                if (this.OrdinalDictionary != null)
                    hashCode = hashCode * 59 + this.OrdinalDictionary.GetHashCode();
                if (this.DecimalCount != null)
                    hashCode = hashCode * 59 + this.DecimalCount.GetHashCode();
                if (this.IncludeLargerSmaller != null)
                    hashCode = hashCode * 59 + this.IncludeLargerSmaller.GetHashCode();
                if (this.Vertical != null)
                    hashCode = hashCode * 59 + this.Vertical.GetHashCode();
                if (this.Font != null)
                    hashCode = hashCode * 59 + this.Font.GetHashCode();
                if (this.Properties3d != null)
                    hashCode = hashCode * 59 + this.Properties3d.GetHashCode();
                if (this.Properties2d != null)
                    hashCode = hashCode * 59 + this.Properties2d.GetHashCode();
                if (this.UserData != null)
                    hashCode = hashCode * 59 + this.UserData.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            foreach(var x in base.BaseValidate(validationContext)) yield return x;

            
            // Type (string) pattern
            Regex regexType = new Regex(@"^LegendParameters$", RegexOptions.CultureInvariant);
            if (this.Type != null && false == regexType.Match(this.Type).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Type, must match a pattern of " + regexType, new [] { "Type" });
            }


            

            
            // DecimalCount (int) minimum
            if(this.DecimalCount < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DecimalCount, must be a value greater than or equal to 0.", new [] { "DecimalCount" });
            }

            yield break;
        }
    }
}
